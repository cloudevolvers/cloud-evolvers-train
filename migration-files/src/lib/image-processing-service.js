import path from 'path';
import axios from 'axios';
import fs from 'fs';
import { getLocalImageStorage } from '../../routes/local-image-storage.js'; // Adjust path as needed

// Initialize local storage service
const localImageStorage = getLocalImageStorage();

// --- Configuration ---
const UNSPLASH_ACCESS_KEY = process.env.UNSPLASH_ACCESS_KEY || '0szr3hk0-ZaGccwXZESK65pP8u70Jo0s03FoJGW9JFY';
const PEXELS_API_KEY = process.env.PEXELS_API_KEY || 'VTItrLboogutOoz31jVCDNsLmydi8F9mlnAnL1ss8sg0mOE7It2W1nqe';
const PIXABAY_API_KEY = process.env.PIXABAY_API_KEY || '49374219-64419a98644ac5a904a552359';

// --- Helper Functions ---

function maskApiKey(key, revealLength = 4) {
    if (!key) return null;
    if (key.length <= revealLength * 2) return '****';
    const prefix = key.substring(0, revealLength);
    const suffix = key.substring(key.length - revealLength);
    const masked = '*'.repeat(key.length - (revealLength * 2));
    return `${prefix}${masked}${suffix}`;
}

function parseMetadata(metadataString) {
    try {
        return metadataString ? JSON.parse(metadataString) : {};
    } catch (e) {
        console.error('Error parsing metadata:', e);
        return {};
    }
}

// --- Service Methods ---

export const getApiKeys = () => {
    return {
        unsplash: { key: maskApiKey(UNSPLASH_ACCESS_KEY), exists: !!UNSPLASH_ACCESS_KEY },
        pexels: { key: maskApiKey(PEXELS_API_KEY), exists: !!PEXELS_API_KEY },
        pixabay: { key: maskApiKey(PIXABAY_API_KEY), exists: !!PIXABAY_API_KEY }
    };
};

export const listLocalBlogImages = () => {
    return localImageStorage.listImages(
        localImageStorage.getBlogImagesDir(),
        filename => localImageStorage.getBlogImageUrl(filename)
    );
};

export const handleGeneralUpload = (file, body) => {
    if (!file) {
        throw new Error('No image file provided');
    }
    const metadata = parseMetadata(body.metadata);
    const section = (body.section || metadata.section || 'blog').toLowerCase();
    const isLocalDev = process.env.LOCAL_DEV === 'true';
    console.log(`Processing uploaded image for section: ${section}, isLocalDev=${isLocalDev}, metadata:`, metadata);

    let targetDir, filenamePrefix, getImageUrlFn;
    const timestamp = Date.now();
    const originalExt = path.extname(file.originalname).toLowerCase();
    const filenameSuffix = `${timestamp}${originalExt}`;

    switch (section) {
        case 'showcase':
            targetDir = localImageStorage.getShowcaseImagesDir();
            filenamePrefix = 'showcase';
            getImageUrlFn = localImageStorage.getShowcaseImageUrl;
            break;
        case 'services':
        case 'service':
            targetDir = localImageStorage.getServicesImagesDir();
            filenamePrefix = `service-${metadata.serviceId || 'unknown'}`;
            getImageUrlFn = localImageStorage.getServiceImageUrl;
            break;
        default: // blog
            targetDir = localImageStorage.getBlogImagesDir();
            filenamePrefix = 'blog';
            getImageUrlFn = localImageStorage.getBlogImageUrl;
            break;
    }

    const finalFilename = `${filenamePrefix}-${filenameSuffix}`;
    const finalPath = path.join(targetDir, finalFilename);

    // Ensure directory exists
    if (!fs.existsSync(targetDir)) {
        fs.mkdirSync(targetDir, { recursive: true });
    }

    // Move the uploaded file (Multer saves it to a temp path initially if using diskStorage directly in route)
    // If multer saves directly to targetDir, we might just need to rename based on section logic
    // Assuming multer saves to the correct section dir based on setup in image-routes.js
    // We might need to rename if the filename generated by multer isn't final
    if (file.path !== finalPath && fs.existsSync(file.path)) {
         // Check if the destination path already exists (unlikely with timestamp, but good practice)
        if (fs.existsSync(finalPath)) {
            console.warn(`Destination file already exists: ${finalPath}. Overwriting.`);
            fs.unlinkSync(finalPath); // Or handle differently, e.g., generate new name
        }
        fs.renameSync(file.path, finalPath);
        console.log(`Moved uploaded file from ${file.path} to ${finalPath}`);
        file.path = finalPath; // Update file info
        file.filename = finalFilename; // Update file info
    } else if (!fs.existsSync(finalPath)) {
         // If the file path IS the final path but doesn't exist, something went wrong
         console.error(`Uploaded file expected at ${finalPath} but not found.`);
         // Attempt to use original path if it exists
         if (fs.existsSync(file.path)) {
             finalPath = file.path; // Use original path
             finalFilename = file.filename; // Use original filename
             console.warn(`Using original upload path: ${finalPath}`);
         } else {
            throw new Error(`Uploaded file not found at ${file.path} or ${finalPath}`);
         }
    } else {
        // File is already at the correct final path
        console.log(`File already correctly placed at ${finalPath}`);
        finalFilename = path.basename(finalPath); // Ensure filename is correct
        file.filename = finalFilename; // Update file info
    }


    const imageUrl = getImageUrlFn(finalFilename);

    // Save metadata file
    const metadataPath = path.join(targetDir, `${finalFilename}.json`);
    const fullMetadata = {
        ...metadata,
        originalName: file.originalname,
        uploadedAt: new Date().toISOString(),
        size: file.size,
        mimeType: file.mimetype,
        section: section,
    };
    fs.writeFileSync(metadataPath, JSON.stringify(fullMetadata, null, 2));

    return {
        success: true,
        url: imageUrl,
        path: finalPath,
        name: file.originalname,
        id: finalFilename, // Use filename as ID
        size: file.size,
        metadata: fullMetadata,
        section: section
    };
};

export const deleteBlogImage = (imageId) => {
    return localImageStorage.deleteImage(
        localImageStorage.getBlogImagesDir(),
        imageId,
        null // No public dir copy
    );
};

export const getProviderStatus = async () => {
    const results = {
        unsplash: { status: 'unknown', message: 'Not checked', keyPartial: maskApiKey(UNSPLASH_ACCESS_KEY) },
        pexels: { status: 'unknown', message: 'Not checked', keyPartial: maskApiKey(PEXELS_API_KEY) },
        pixabay: { status: 'unknown', message: 'Not checked', keyPartial: maskApiKey(PIXABAY_API_KEY) },
        local: { status: 'operational', message: 'Local storage available' }
    };

    // Check Unsplash
    try {
        const unsplashResponse = await axios.get('https://api.unsplash.com/photos', {
            headers: { 'Authorization': `Client-ID ${UNSPLASH_ACCESS_KEY}`, 'Accept-Version': 'v1' },
            params: { per_page: 1, client_id: UNSPLASH_ACCESS_KEY }
        });
        if (unsplashResponse.status === 200) results.unsplash = { ...results.unsplash, status: 'operational', message: 'API connection successful' };
    } catch (error) {
        results.unsplash = { ...results.unsplash, status: 'error', message: error.response?.status === 401 ? 'Invalid API key' : 'Connection failed' };
    }

    // Check Pexels
    try {
        const pexelsResponse = await axios.get('https://api.pexels.com/v1/curated', {
            headers: { 'Authorization': PEXELS_API_KEY }, params: { per_page: 1 }
        });
        if (pexelsResponse.status === 200) results.pexels = { ...results.pexels, status: 'operational', message: 'API connection successful' };
    } catch (error) {
        results.pexels = { ...results.pexels, status: 'error', message: error.response?.status === 401 ? 'Invalid API key' : 'Connection failed' };
    }

    // Check Pixabay
    try {
        const pixabayResponse = await axios.get('https://pixabay.com/api/', {
            params: { key: PIXABAY_API_KEY, per_page: 1 }
        });
        if (pixabayResponse.status === 200) results.pixabay = { ...results.pixabay, status: 'operational', message: 'API connection successful' };
    } catch (error) {
        results.pixabay = { ...results.pixabay, status: 'error', message: error.response?.status === 401 ? 'Invalid API key' : 'Connection failed' };
    }

    return results;
};

// --- Search Functions ---

const searchUnsplash = async (query, page, per_page) => {
    try {
        const response = await axios.get('https://api.unsplash.com/search/photos', {
            headers: { 'Authorization': `Client-ID ${UNSPLASH_ACCESS_KEY}`, 'Accept-Version': 'v1' },
            params: { query, page, per_page, client_id: UNSPLASH_ACCESS_KEY }
        });
        return {
            images: response.data.results.map(image => ({
                id: image.id, name: image.description || image.alt_description || 'Unsplash image',
                url: image.urls.regular, thumbnail: image.urls.small, source: 'unsplash',
                sourceUrl: image.links.html, authorName: image.user.name, authorUrl: image.user.links.html,
                width: image.width, height: image.height
            })),
            total: response.data.total,
            total_pages: Math.ceil(response.data.total / per_page)
        };
    } catch (error) {
        console.error('Unsplash search error:', error.message);
        return { images: [], total: 0, total_pages: 0, error: error.message };
    }
};

const searchPexels = async (query, page, per_page) => {
     try {
        const response = await axios.get('https://api.pexels.com/v1/search', {
            headers: { 'Authorization': PEXELS_API_KEY }, params: { query, page, per_page }
        });
        return {
            images: response.data.photos.map(photo => ({
                id: photo.id, name: photo.alt || 'Pexels image', url: photo.src.large,
                thumbnail: photo.src.medium, source: 'pexels', sourceUrl: photo.url,
                authorName: photo.photographer, authorUrl: photo.photographer_url,
                width: photo.width, height: photo.height
            })),
            total: response.data.total_results,
            total_pages: Math.ceil(response.data.total_results / per_page)
        };
    } catch (error) {
        console.error('Pexels search error:', error.message);
        return { images: [], total: 0, total_pages: 0, error: error.message };
    }
};

const searchPixabay = async (query, page, per_page) => {
    if (!PIXABAY_API_KEY) return { images: [], total: 0, total_pages: 0, error: 'Pixabay API key not configured' };
    try {
        const response = await axios.get('https://pixabay.com/api/', {
            params: { key: PIXABAY_API_KEY, q: query, page, per_page, image_type: 'photo' },
            timeout: 5000
        });
        return {
            images: response.data.hits.map(hit => ({
                id: hit.id, name: hit.tags.split(',')[0] || 'Pixabay image', url: hit.largeImageURL,
                thumbnail: hit.webformatURL, source: 'pixabay', sourceUrl: hit.pageURL,
                authorName: hit.user, authorUrl: `https://pixabay.com/users/${hit.user}-${hit.user_id}/`,
                width: hit.imageWidth, height: hit.imageHeight
            })),
            total: response.data.totalHits,
            total_pages: Math.ceil(response.data.totalHits / per_page)
        };
    } catch (error) {
        console.error('Pixabay search error:', error.message);
        return { images: [], total: 0, total_pages: 0, error: error.message };
    }
};

const searchLocal = (query) => {
    try {
        const imagesDir = localImageStorage.getBlogImagesDir(); // Search blog images for now
        if (!fs.existsSync(imagesDir)) return [];

        const searchTerm = query.toLowerCase();
        return fs.readdirSync(imagesDir)
            .filter(file => {
                const ext = path.extname(file).toLowerCase();
                return ['.jpg', '.jpeg', '.png', '.gif', '.webp'].includes(ext) &&
                       file.toLowerCase().includes(searchTerm);
            })
            .map(file => ({
                id: file, name: file, url: localImageStorage.getBlogImageUrl(file),
                thumbnail: localImageStorage.getBlogImageUrl(file), source: 'local',
                sourceUrl: null, authorName: 'Local Storage', width: 800, height: 600 // Default size
            }));
    } catch (error) {
        console.error('Error searching local images:', error);
        return [];
    }
};

export const searchImages = async (query, page = 1, per_page = 30, provider = 'all') => {
    if (!query) throw new Error('Search query is required');

    const results = { images: [], sourceStats: { local: 0, unsplash: 0, pexels: 0, pixabay: 0 }, total: 0 };
    const providerPage = parseInt(page, 10);
    const providerPerPage = parseInt(per_page, 10);

    if (provider === 'all' || provider === 'local') {
        const localResults = searchLocal(query);
        results.images.push(...localResults);
        results.sourceStats.local = localResults.length;
    }

    // For external providers, adjust per_page if searching 'all'
    const externalPerPage = provider === 'all' ? Math.max(1, Math.floor(providerPerPage / 3)) : providerPerPage;

    const promises = [];
    if (provider === 'all' || provider === 'unsplash') {
        promises.push(searchUnsplash(query, providerPage, externalPerPage));
    }
    if (provider === 'all' || provider === 'pexels') {
        promises.push(searchPexels(query, providerPage, externalPerPage));
    }
    if (provider === 'all' || provider === 'pixabay') {
        promises.push(searchPixabay(query, providerPage, externalPerPage));
    }

    const externalResults = await Promise.all(promises);

    externalResults.forEach(result => {
        if (result && result.images) {
            results.images.push(...result.images);
            if (result.images.length > 0) {
                 const source = result.images[0].source; // Assuming all images in a result have same source
                 results.sourceStats[source] = result.images.length;
            }
        }
    });

    // If searching 'all', limit the combined results
    if (provider === 'all') {
        results.images = results.images.slice(0, providerPerPage);
    }

    results.total = results.images.length;
    return results;
};

// --- Image Serving ---

export const serveImageFile = (section, filename, res) => {
    const sanitizedFilename = path.basename(filename).replace(/[^a-zA-Z0-9-_.]/g, '');
    let imageDir;
    let defaultImagePath;
    let routePrefix = '/backend/images';

    switch (section) {
        case 'blog':
            imageDir = localImageStorage.getBlogImagesDir();
            defaultImagePath = null; // No static fallback, always use backend
            routePrefix = '/backend/images/blog';
            break;
        case 'services':
            imageDir = localImageStorage.getServicesImagesDir();
            defaultImagePath = null;
            routePrefix = '/backend/images/services';
            break;
        case 'showcase':
            imageDir = localImageStorage.getShowcaseImagesDir();
            defaultImagePath = null;
            routePrefix = '/backend/images/showcase';
            break;
        default:
            console.warn(`Unknown section for serving image: ${section}`);
            return res.status(400).send('Invalid image section');
    }

    const filePath = path.join(imageDir, sanitizedFilename);
    localImageStorage.streamImageToResponse(filePath, res, defaultImagePath);
};


// --- Image Saving/Manipulation ---

export const saveImageFromProvider = async (imageUrl, name, section = 'blog', metadata = {}) => {
    if (!imageUrl) throw new Error('No image URL provided');

    const timestamp = Date.now();
    const imageName = name || `${section}_image_${timestamp}`;
    console.log(`Saving external image: ${imageName} from ${imageUrl} for section: ${section}`);

    const response = await axios.get(imageUrl, { responseType: 'arraybuffer', timeout: 15000 });
    const contentType = response.headers['content-type'];
    let fileExtension = '.jpg';
    if (contentType) {
        if (contentType.includes('png')) fileExtension = '.png';
        else if (contentType.includes('gif')) fileExtension = '.gif';
        else if (contentType.includes('webp')) fileExtension = '.webp';
        else if (contentType.includes('jpeg')) fileExtension = '.jpg';
    }

    const safeSection = section.replace(/[^a-z0-9]/gi, '-').toLowerCase();
    const filename = `${safeSection}-${timestamp}${fileExtension}`;

    let targetDir, urlSectionPath, getImageUrlFn;
    if (section === 'blog') {
        targetDir = localImageStorage.getBlogImagesDir();
        urlSectionPath = 'blog-images'; // Used for manual URL construction if needed
        getImageUrlFn = localImageStorage.getBlogImageUrl;
    } else if (section === 'services' || section === 'service') {
        targetDir = localImageStorage.getServicesImagesDir();
        urlSectionPath = 'service-images';
        getImageUrlFn = localImageStorage.getServiceImageUrl;
    } else if (section === 'showcase') {
        targetDir = localImageStorage.getShowcaseImagesDir();
        urlSectionPath = 'showcase-images';
        getImageUrlFn = localImageStorage.getShowcaseImageUrl;
    } else {
        console.warn(`Unknown section '${section}', defaulting to 'blog'.`);
        targetDir = localImageStorage.getBlogImagesDir();
        urlSectionPath = 'blog-images';
        getImageUrlFn = localImageStorage.getBlogImageUrl;
    }

     if (!fs.existsSync(targetDir)) {
        fs.mkdirSync(targetDir, { recursive: true });
     }

    localImageStorage.saveImageFromData(Buffer.from(response.data), targetDir, filename);

    const finalImageUrl = getImageUrlFn(filename); // Use the getter for consistency

    const fullMetadata = {
        ...metadata, originalUrl: imageUrl, savedAt: new Date().toISOString(),
        name: imageName, isLocalCopy: true, copiedFrom: metadata.source || 'unknown', section
    };

    try {
        const metadataPath = path.join(targetDir, `${filename}.json`);
        await fs.promises.writeFile(metadataPath, JSON.stringify(fullMetadata, null, 2));
    } catch (metadataError) {
        console.error('Error saving image metadata:', metadataError);
    }

    return {
        success: true, url: finalImageUrl, name: imageName, id: filename, section, metadata: fullMetadata
    };
};

export const savePastedShowcaseImage = (imageBase64, name, mimeType, metadata = {}) => {
    const buffer = Buffer.from(imageBase64, 'base64');
    const timestamp = Date.now();
    const extension = mimeType.split('/')[1] || 'png';
    const filename = `showcase-pasted-${timestamp}.${extension}`; // Added 'pasted' prefix
    const showcaseDir = localImageStorage.getShowcaseImagesDir();

    if (!fs.existsSync(showcaseDir)) {
        fs.mkdirSync(showcaseDir, { recursive: true });
    }

    const filePath = path.join(showcaseDir, filename);
    fs.writeFileSync(filePath, buffer);

    const imageUrl = localImageStorage.getShowcaseImageUrl(filename);
    console.log(`Pasted showcase image saved: ${filePath}`);

    // Save metadata
     const fullMetadata = {
        ...metadata, originalName: name, uploadedAt: new Date().toISOString(),
        mimeType: mimeType, isPasted: true, section: 'showcase'
    };
     try {
        const metadataPath = path.join(showcaseDir, `${filename}.json`);
        fs.writeFileSync(metadataPath, JSON.stringify(fullMetadata, null, 2));
    } catch (metadataError) {
        console.error('Error saving pasted image metadata:', metadataError);
    }


    return { success: true, url: imageUrl, id: filename, name, metadata: fullMetadata };
};

export const handleCroppedImage = async (file, body) => {
     if (!file || !file.buffer) {
        throw new Error('No cropped image data uploaded');
    }
    const metadata = parseMetadata(body.metadata);
    const section = (metadata.section || 'blog').toLowerCase();
    console.log(`Cropping image for section: ${section}`);

    metadata.isCropped = true;
    metadata.originalId = metadata.originalId || null;
    metadata.cropDate = new Date().toISOString();

    let targetDir, getImageUrlFn, filename;
    const timestamp = Date.now();
    const originalExt = path.extname(metadata.name || file.originalname || 'image.jpg').toLowerCase();
    const fileExtension = ['.jpg', '.jpeg', '.png', '.gif', '.webp'].includes(originalExt) ? originalExt : '.jpg';

    if (section === 'showcase') {
        targetDir = localImageStorage.getShowcaseImagesDir();
        getImageUrlFn = localImageStorage.getShowcaseImageUrl;
        filename = `showcase-cropped-${timestamp}${fileExtension}`;
    } else if (section === 'service' || section === 'services') {
        targetDir = localImageStorage.getServicesImagesDir();
        getImageUrlFn = localImageStorage.getServiceImageUrl;
        const serviceId = metadata.serviceId || 'unknown';
        filename = `service-${serviceId}-cropped-${timestamp}${fileExtension}`;
    } else { // Default to blog
        targetDir = localImageStorage.getBlogImagesDir();
        getImageUrlFn = localImageStorage.getBlogImageUrl;
        filename = `blog-cropped-${timestamp}${fileExtension}`;
    }

    const savedPath = localImageStorage.saveImageFromData(file.buffer, targetDir, filename);
    console.log(`Cropped image saved to: ${savedPath}`);
    const imageUrl = getImageUrlFn(filename);

    try {
        const metadataPath = path.join(targetDir, `${filename}.json`);
        await fs.promises.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
    } catch (metaError) {
        console.error(`Failed to save metadata for cropped image ${filename}:`, metaError);
    }

    return { success: true, url: imageUrl, id: filename, metadata, isCropped: true, section };
};


// --- Other ---

export const getStorageInfo = () => {
    const info = localImageStorage.getStorageInfo();
    info.environment = {
        NODE_ENV: process.env.NODE_ENV || 'not set',
        LOCAL_DEV: process.env.LOCAL_DEV || 'not set',
        LOCAL_DEV_PARSED: process.env.LOCAL_DEV === 'true',
        path: process.cwd(),
        development: process.env.NODE_ENV !== 'production'
    };
    return info;
};

export const refreshEnvironment = (forceLocalDev) => {
    localImageStorage.resetEnvironment(forceLocalDev);
    return getStorageInfo(); // Return updated info
};

export const getBlogImageInfo = (slug, category) => {
     if (!slug) throw new Error('Missing slug parameter');

    const blogImagesPath = localImageStorage.getBlogImagesDir();
    const categoryImageMap = {
        'Azure Security': '/images/blog/security.jpg', 'API Management': '/images/blog/api-management.jpg',
        'Identity': '/images/blog/identity.jpg', 'DevOps': '/images/blog/devops.jpg',
    };
    const defaultImage = '/images/blog/default-blog-image.jpg';

    const slugBasedFilename = `${slug}.jpg`; // Assuming .jpg, might need more robust check
    const fullImagePath = path.join(blogImagesPath, slugBasedFilename);

    if (fs.existsSync(fullImagePath)) {
        return { success: true, imagePath: localImageStorage.getBlogImageUrl(slugBasedFilename) };
    }
    if (category && categoryImageMap[category]) {
        return { success: true, imagePath: categoryImageMap[category] };
    }
    return { success: true, imagePath: defaultImage };
};

export const updateImageMetadata = async (imageId, updates) => {
    // Assuming imageId is the filename and metadata is stored alongside
    // Determine section based on filename prefix or assume blog for simplicity here
    const imagesDir = localImageStorage.getBlogImagesDir(); // Needs logic to find correct dir
    const imagePath = path.join(imagesDir, imageId);

    if (!fs.existsSync(imagePath)) {
        throw new Error('Image not found');
    }

    const metadataPath = path.join(imagesDir, `${imageId}.json`);
    let existingMetadata = {};
    if (fs.existsSync(metadataPath)) {
        try {
            existingMetadata = JSON.parse(await fs.promises.readFile(metadataPath, 'utf8'));
        } catch (err) {
            console.error(`Error reading metadata for ${imageId}:`, err);
        }
    }

    const updatedMetadata = { ...existingMetadata, ...updates, updatedAt: new Date().toISOString() };
    await fs.promises.writeFile(metadataPath, JSON.stringify(updatedMetadata, null, 2));

    const imageUrl = localImageStorage.getBlogImageUrl(imageId); // Needs logic for correct URL getter
    return { success: true, id: imageId, url: imageUrl, metadata: updatedMetadata };
};
